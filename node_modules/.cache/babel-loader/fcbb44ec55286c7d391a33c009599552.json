{"ast":null,"code":"'use strict';\n\nconst makeRequest = require('./makeRequest');\n\nconst utils = require('./utils');\n\nfunction makeAutoPaginationMethods(self, requestArgs, spec, firstPagePromise) {\n  const promiseCache = {\n    currentPromise: null\n  };\n  const reverseIteration = isReverseIteration(requestArgs);\n  let pagePromise = firstPagePromise;\n  let i = 0; // Search and List methods iterate differently.\n  // Search relies on a `next_page` token and can only iterate in one direction.\n  // List relies on either an `ending_before` or `starting_after` field with\n  // an item ID to paginate and is bi-directional.\n  //\n  // Please note: spec.methodType === 'search' is beta functionality and is\n  // subject to change/removal at any time.\n\n  let getNextPagePromise;\n\n  if (spec.methodType === 'search') {\n    getNextPagePromise = pageResult => {\n      if (!pageResult.next_page) {\n        throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n      }\n\n      return makeRequest(self, requestArgs, spec, {\n        page: pageResult.next_page\n      });\n    };\n  } else {\n    getNextPagePromise = pageResult => {\n      const lastId = getLastId(pageResult, reverseIteration);\n      return makeRequest(self, requestArgs, spec, {\n        [reverseIteration ? 'ending_before' : 'starting_after']: lastId\n      });\n    };\n  }\n\n  function iterate(pageResult) {\n    if (!(pageResult && pageResult.data && typeof pageResult.data.length === 'number')) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n    }\n\n    if (i < pageResult.data.length) {\n      const idx = reverseIteration ? pageResult.data.length - 1 - i : i;\n      const value = pageResult.data[idx];\n      i += 1;\n      return {\n        value,\n        done: false\n      };\n    } else if (pageResult.has_more) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      pagePromise = getNextPagePromise(pageResult);\n      return pagePromise.then(iterate);\n    }\n\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, (resolve, reject) => {\n      return pagePromise.then(iterate).then(resolve).catch(reject);\n    });\n  }\n\n  const autoPagingEach = makeAutoPagingEach(asyncIteratorNext);\n  const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n  const autoPaginationMethods = {\n    autoPagingEach,\n    autoPagingToArray,\n    // Async iterator functions:\n    next: asyncIteratorNext,\n    return: () => {\n      // This is required for `break`.\n      return {};\n    },\n    [getAsyncIteratorSymbol()]: () => {\n      return autoPaginationMethods;\n    }\n  };\n  return autoPaginationMethods;\n}\n\nmodule.exports.makeAutoPaginationMethods = makeAutoPaginationMethods;\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\n\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  } // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n\n\n  return '@@asyncIterator';\n}\n\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return undefined;\n  }\n\n  const onDone = args[1];\n\n  if (typeof onDone !== 'function') {\n    throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);\n  }\n\n  return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\n\n\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n\n  const onItem = args[0];\n\n  if (typeof onItem !== 'function') {\n    throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);\n  } // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n\n\n  if (onItem.length === 2) {\n    return onItem;\n  }\n\n  if (onItem.length > 2) {\n    throw Error(`The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);\n  } // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n\n\n  return function _onItem(item, next) {\n    const shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\n\nfunction getLastId(listResult, reverseIteration) {\n  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n  const lastItem = listResult.data[lastIdx];\n  const lastId = lastItem && lastItem.id;\n\n  if (!lastId) {\n    throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n  }\n\n  return lastId;\n}\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\n\n\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n\n  promiseCache.currentPromise = new Promise(cb).then(ret => {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\n\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function\n    /* onItem?, onDone? */\n  autoPagingEach() {\n    const args = [].slice.call(arguments);\n    const onItem = getItemCallback(args);\n    const onDone = getDoneCallback(args);\n\n    if (args.length > 2) {\n      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n    }\n\n    const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem);\n    return utils.callbackifyPromiseWithTimeout(autoPagePromise, onDone);\n  };\n}\n\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    const limit = opts && opts.limit;\n\n    if (!limit) {\n      throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n    }\n\n    if (limit > 10000) {\n      throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      const items = [];\n      autoPagingEach(item => {\n        items.push(item);\n\n        if (items.length >= limit) {\n          return false;\n        }\n      }).then(() => {\n        resolve(items);\n      }).catch(reject);\n    });\n    return utils.callbackifyPromiseWithTimeout(promise, onDone);\n  };\n}\n\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise((resolve, reject) => {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n\n      const item = iterResult.value;\n      return new Promise(next => {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then(shouldContinue => {\n        if (shouldContinue === false) {\n          return handleIteration({\n            done: true\n          });\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n\n    asyncIteratorNext().then(handleIteration).catch(reject);\n  });\n}\n\nfunction isReverseIteration(requestArgs) {\n  const args = [].slice.call(requestArgs);\n  const dataFromArgs = utils.getDataFromArgs(args);\n  return !!dataFromArgs.ending_before;\n}","map":{"version":3,"names":["makeRequest","require","utils","makeAutoPaginationMethods","self","requestArgs","spec","firstPagePromise","promiseCache","currentPromise","reverseIteration","isReverseIteration","pagePromise","i","getNextPagePromise","methodType","pageResult","next_page","Error","page","lastId","getLastId","iterate","data","length","idx","value","done","has_more","then","undefined","asyncIteratorNext","memoizedPromise","resolve","reject","catch","autoPagingEach","makeAutoPagingEach","autoPagingToArray","makeAutoPagingToArray","autoPaginationMethods","next","return","getAsyncIteratorSymbol","module","exports","Symbol","asyncIterator","getDoneCallback","args","onDone","getItemCallback","onItem","_onItem","item","shouldContinue","listResult","lastIdx","lastItem","id","cb","Promise","ret","slice","call","arguments","autoPagePromise","wrapAsyncIteratorWithCallback","callbackifyPromiseWithTimeout","opts","limit","promise","items","push","handleIteration","iterResult","dataFromArgs","getDataFromArgs","ending_before"],"sources":["/Users/joris/Library/Mobile Documents/com~apple~CloudDocs/OneDrive v1/34. Projects/stripe-prebuilt/node_modules/stripe/lib/autoPagination.js"],"sourcesContent":["'use strict';\n\nconst makeRequest = require('./makeRequest');\nconst utils = require('./utils');\n\nfunction makeAutoPaginationMethods(self, requestArgs, spec, firstPagePromise) {\n  const promiseCache = {currentPromise: null};\n  const reverseIteration = isReverseIteration(requestArgs);\n  let pagePromise = firstPagePromise;\n  let i = 0;\n\n  // Search and List methods iterate differently.\n  // Search relies on a `next_page` token and can only iterate in one direction.\n  // List relies on either an `ending_before` or `starting_after` field with\n  // an item ID to paginate and is bi-directional.\n  //\n  // Please note: spec.methodType === 'search' is beta functionality and is\n  // subject to change/removal at any time.\n  let getNextPagePromise;\n  if (spec.methodType === 'search') {\n    getNextPagePromise = (pageResult) => {\n      if (!pageResult.next_page) {\n        throw Error(\n          'Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.'\n        );\n      }\n      return makeRequest(self, requestArgs, spec, {\n        page: pageResult.next_page,\n      });\n    };\n  } else {\n    getNextPagePromise = (pageResult) => {\n      const lastId = getLastId(pageResult, reverseIteration);\n      return makeRequest(self, requestArgs, spec, {\n        [reverseIteration ? 'ending_before' : 'starting_after']: lastId,\n      });\n    };\n  }\n\n  function iterate(pageResult) {\n    if (\n      !(\n        pageResult &&\n        pageResult.data &&\n        typeof pageResult.data.length === 'number'\n      )\n    ) {\n      throw Error(\n        'Unexpected: Stripe API response does not have a well-formed `data` array.'\n      );\n    }\n\n    if (i < pageResult.data.length) {\n      const idx = reverseIteration ? pageResult.data.length - 1 - i : i;\n      const value = pageResult.data[idx];\n      i += 1;\n\n      return {value, done: false};\n    } else if (pageResult.has_more) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      pagePromise = getNextPagePromise(pageResult);\n      return pagePromise.then(iterate);\n    }\n    return {value: undefined, done: true};\n  }\n\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, (resolve, reject) => {\n      return pagePromise\n        .then(iterate)\n        .then(resolve)\n        .catch(reject);\n    });\n  }\n\n  const autoPagingEach = makeAutoPagingEach(asyncIteratorNext);\n  const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n\n  const autoPaginationMethods = {\n    autoPagingEach,\n    autoPagingToArray,\n\n    // Async iterator functions:\n    next: asyncIteratorNext,\n    return: () => {\n      // This is required for `break`.\n      return {};\n    },\n    [getAsyncIteratorSymbol()]: () => {\n      return autoPaginationMethods;\n    },\n  };\n  return autoPaginationMethods;\n}\n\nmodule.exports.makeAutoPaginationMethods = makeAutoPaginationMethods;\n\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\n\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  }\n  // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n  return '@@asyncIterator';\n}\n\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return undefined;\n  }\n  const onDone = args[1];\n  if (typeof onDone !== 'function') {\n    throw Error(\n      `The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`\n    );\n  }\n  return onDone;\n}\n\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n  const onItem = args[0];\n  if (typeof onItem !== 'function') {\n    throw Error(\n      `The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`\n    );\n  }\n\n  // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n  if (onItem.length === 2) {\n    return onItem;\n  }\n\n  if (onItem.length > 2) {\n    throw Error(\n      `The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`\n    );\n  }\n\n  // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n  return function _onItem(item, next) {\n    const shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\n\nfunction getLastId(listResult, reverseIteration) {\n  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n  const lastItem = listResult.data[lastIdx];\n  const lastId = lastItem && lastItem.id;\n  if (!lastId) {\n    throw Error(\n      'Unexpected: No `id` found on the last item while auto-paging a list.'\n    );\n  }\n  return lastId;\n}\n\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n  promiseCache.currentPromise = new Promise(cb).then((ret) => {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\n\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function autoPagingEach(/* onItem?, onDone? */) {\n    const args = [].slice.call(arguments);\n    const onItem = getItemCallback(args);\n    const onDone = getDoneCallback(args);\n    if (args.length > 2) {\n      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n    }\n\n    const autoPagePromise = wrapAsyncIteratorWithCallback(\n      asyncIteratorNext,\n      onItem\n    );\n    return utils.callbackifyPromiseWithTimeout(autoPagePromise, onDone);\n  };\n}\n\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    const limit = opts && opts.limit;\n    if (!limit) {\n      throw Error(\n        'You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.'\n      );\n    }\n    if (limit > 10000) {\n      throw Error(\n        'You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.'\n      );\n    }\n    const promise = new Promise((resolve, reject) => {\n      const items = [];\n      autoPagingEach((item) => {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      })\n        .then(() => {\n          resolve(items);\n        })\n        .catch(reject);\n    });\n    return utils.callbackifyPromiseWithTimeout(promise, onDone);\n  };\n}\n\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise((resolve, reject) => {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n\n      const item = iterResult.value;\n      return new Promise((next) => {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then((shouldContinue) => {\n        if (shouldContinue === false) {\n          return handleIteration({done: true});\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n\n    asyncIteratorNext()\n      .then(handleIteration)\n      .catch(reject);\n  });\n}\n\nfunction isReverseIteration(requestArgs) {\n  const args = [].slice.call(requestArgs);\n  const dataFromArgs = utils.getDataFromArgs(args);\n\n  return !!dataFromArgs.ending_before;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}